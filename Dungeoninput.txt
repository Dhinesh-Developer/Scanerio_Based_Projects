The  "dungeon game" problem typically asks candidates to design a code-based simulation of a dungeon scenario, involving **entities such as an adventurer, monster, triggers, pits, and treasure**. The core challenge is to build a multi-module game system (logic only, no graphics) where the adventurer must **reach the treasure before the monster does—or else the adventurer dies**.[1][2][3]

## Problem Statement Breakdown

- Dungeon Grid: The game is set on a matrix/grid, where each cell may contain different elements: ground, pits, triggers, treasure, adventurer, monster, etc..[3][1]
- Entities:
  - Adventurer: Starts at a given position; must navigate the dungeon to reach the treasure.
  - Monster: Also starts at a different location; moves toward the treasure.[3]
  - Triggers/Pits: Special cells that might hinder or kill the player.
  - Treasure: The destination; the goal is to reach it safely and ahead of the monster.[3]
- Movement:Positions and the size of the grid are provided at runtime. Both adventurer and monster move stepwise according to certain rules (often Manhattan or Euclidean distance).
-Winning/Losing Condition: The adventurer must reach the treasure **before the monster**; if not, the player fails.[1][3]
- Modules: The question is split into various tasks—creating the grid, placing entities, handling movement logic, checking win/loss conditions, and more. Each module is validated separately.[1][3]
- Implementation: Candidates are asked to design and implement each part, with each module building on the previous ones. Often dynamic programming, BFS/DFS, or other path-planning algorithms are involved if asked for optimal path computation.[2][4]

## Example Scenario

- Input:
  - Size and positions for adventurer, monster, treasure, pits, etc.
- Output:
  - Simulate steps and determine if the adventurer safely reaches the treasure before the monster.
- Hint Calculating shortest distances (e.g., using absolute differences for monster distance) is usually part of the solution.[1][3]



